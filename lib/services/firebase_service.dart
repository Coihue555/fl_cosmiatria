import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:fl_cosmiatria/models/caso_model.dart';
import 'package:fl_cosmiatria/models/paciente_model.dart'; // Assuming PacienteModel is stored here
import 'package:fl_cosmiatria/views/auth.dart';

FirebaseFirestore db = FirebaseFirestore.instance;
final User? user = Auth().currentUser;

Future<List<PacienteModel>> getPacientes() async {
  List<PacienteModel> pacientes = [];
  CollectionReference collectionReferencePacientes = db.collection('pacientes');
  if (user == null) {
    return pacientes;
  }
  QuerySnapshot queryPacientes = await collectionReferencePacientes.where('usuario', isEqualTo: user!.email).get();
  for (var doc in queryPacientes.docs) {
    final Map<String, dynamic> data = doc.data() as Map<String, dynamic>;
    PacienteModel paciente = PacienteModel.fromJson({
      ...data,
    });
    pacientes.add(paciente);
  }
  return pacientes;
}

// Future<void> addPaciente(PacienteModel paciente) async {
//   await db.collection('pacientes').add(paciente.toJson());
// }
Future<void> addPaciente(PacienteModel paciente) async {
  // Generate a new document reference with an auto-generated ID
  DocumentReference docRef = db.collection('pacientes').doc();

  // Assign the generated document ID to the paciente's uid field
  paciente.uid = docRef.id;

  // Convert the PacienteModel to JSON, assuming you have a method to do this
  // and that it includes the uid field after assignment
  Map<String, dynamic> pacienteData = paciente.toJson();

  // Set the document at the generated ID with your data
  await docRef.set(pacienteData);
}

Future<void> updatePaciente(PacienteModel paciente) async {
  await db.collection('pacientes').doc(paciente.uid).set(paciente.toJson());
}

Future<void> deletePaciente(String uid) async {
  await db.collection('pacientes').doc(uid).delete();
}

Future<List<dynamic>> filterPacientesByName(String palabra) async {
  List<dynamic> allPacientes = await getPacientes();
  if (palabra.isEmpty) {
    return allPacientes;
  }
  return allPacientes.where((paciente) => paciente.nombre.toLowerCase().contains(palabra.toLowerCase())).toList();
}

Future<List<CasoModel>> findMatchingCases(String nombrePaciente) async {
  List<PacienteModel> lstPacientes = await getPacientes();
  List<CasoModel> lstCasos = await getCasos();

  if (nombrePaciente.isEmpty) {
    return lstCasos;
  } else {
    List<String> matchingPacienteUids = [];
    for (var paciente in lstPacientes) {
      if (paciente.nombre.toLowerCase().contains(nombrePaciente.toLowerCase())) {
        matchingPacienteUids.add(paciente.uid ?? '');
      }
    }

    List<CasoModel> matchingCases = [];
    for (var caso in lstCasos) {
      if (matchingPacienteUids.contains(caso.nombre)) {
        matchingCases.add(caso);
      }
    }
    return matchingCases;
  }
}

///Recibe un uid y retorna el valor de la clave 'label'
Future<String>? getItemDescription(String? itemUid, Future<List<dynamic>> lstItem) async {
  if (itemUid == null) return '';
  var item = await lstItem.then((items) => items.firstWhere((item) => item.uid == itemUid, orElse: () => PacienteModel()));
  return item.nombre ?? 'Seleccione una opcion';
}

Future<String>? getItemName(String? itemUid, Future<List<dynamic>> lstItem) async {
  if (itemUid == null) return '';
  var item = await lstItem.then((items) => items.firstWhere((item) => item.uid == itemUid, orElse: () => PacienteModel()));
  return item.nombre ?? 'Seleccione una opcion';
}

Future<List<CasoModel>> getCasos() async {
  List<CasoModel> casos = [];
  CollectionReference collectionReferenceCasos = db.collection('casos');
  if (user == null) {
    return casos;
  }
  QuerySnapshot queryCasos = await collectionReferenceCasos.where('usuario', isEqualTo: user!.email).get();
  for (var doc in queryCasos.docs) {
    final Map<String, dynamic> data = doc.data() as Map<String, dynamic>;
    CasoModel caso = CasoModel.fromJson({
      ...data,
      //"uid": doc.id // Assuming uid is not part of your document's fields and you want to include it
    });
    casos.add(caso);
  }

  return casos;
}

Future<void> addCaso(CasoModel caso) async {
  DocumentReference docRef = db.collection('casos').doc();
  caso.uid = docRef.id;
  // Exclude the uid when adding a new case since it's generated by Firestore
  Map<String, dynamic> casoData = caso.toJson();
  await docRef.set(casoData);
}

Future<void> updateCaso(CasoModel caso) async {
  // Ensure that the uid is not part of the data to be updated
  Map<String, dynamic> data = caso.toJson();
  String uid = data.remove('uid') as String; // Remove uid and save it for document reference
  await db.collection('casos').doc(uid).set(data);
}

Future<void> deleteCaso(String uid) async {
  await db.collection('casos').doc(uid).delete();
}
